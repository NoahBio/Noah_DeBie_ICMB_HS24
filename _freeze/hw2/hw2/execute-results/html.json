{
  "hash": "b508efa2e05175ce6d24b8ffde333af3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2\"\n\nauthor: \"Noah De Bie\"\n---\n\n\n\n\n::: {.callout-caution appearance=\"simple\"}\nAI (a.k.a. chatGPT a.k.a. *my Guy*) was used in the generation of every morsel of code in this assignment.\n:::\n\nStart with a random Sample of 1000 \"people\" whose wealth is normally distributed. The mean is 10'000 francs and the standard deviation is 5'000:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set parameters for the normal distribution\nmean_wealth <- 10000  # Mean of 10,000 francs\nsd_wealth <- 5000     # Standard deviation of 5,000 francs\nn_people <- 1000      # Sample size of 1000 people\n\n#generating a random sample\npopulation_norm_nodebt <- rnorm(n_people, mean = mean_wealth, sd = sd_wealth)\n# Replace negative values with zero, there are negative values cuz mean/sd=2\npopulation_norm_nodebt<- ifelse(population_norm_nodebt < 0, 0, population_norm_nodebt)\n\n#draw histogram\nhist(population_norm_nodebt, xlab = \"People / Population\", ylab = \"Wealth\", breaks = 25)\n```\n\n::: {.cell-output-display}\n![](hw2_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\nGini Coefficient of the calculated sample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini <- function(y) {\n  # Sort the population\n  y <- sort(y)\n  \n  # Get the number of people in the population\n  n <- length(y)\n  \n  # Compute the numerator\n  numer <- 2 * sum((1:n) * y)\n  \n  # Compute the denominator\n  denom <- n * sum(y)\n  \n  # Return the Gini coefficient\n  return((numer / denom) - (n + 1) / n)\n}\ngini(population_norm_nodebt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2748665\n```\n\n\n:::\n:::\n\n\n\n\nDefining what happens when two agents meet. In time, there may be multiple options here.\n\nThe first option is a random split, where the wealth is combined and then randomly distributed between the two agents.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(wealth_a, wealth_b) {\n   \n   # Total wealth in the pot\n   pot <- wealth_a + wealth_b\n   \n   share_a <- runif(1, 0, pot)\n   share_b <- pot - share_a\n   \n   return(c(share_a, share_b))\n}\n```\n:::\n\n\n\n\nNow on to create a \"meeting-function\" that specifies which two agents meet. To start with, we assume that agents meet completely randomly.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_meeting <- function(n_people) {\n   \n   #the function outputs two randomly sampled people from 1:N\n   return(sample(1:n_people, 2))\n   \n}\n```\n:::\n\n\n\n\nWith both the meeting function and the money distribution function done, I'll now try to simulate the wealth distribution over time by making these functions run loads of times. The first function defines a step\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the step function\nstep <- function(population, transaction, interaction) {\n  # Select two actors using the interaction function\n  actors <- interaction(length(population))\n  \n  # Perform the transaction and update their wealth\n  wealths <- transaction(population[actors[1]], population[actors[2]])\n  \n  # Update the population with the new wealth values\n  population[actors[1]] <- wealths[1]  # Update wealth for Actor 1\n  population[actors[2]] <- wealths[2]  # Update wealth for Actor 2\n  \n  return(population)  # Return the updated population\n}\n\n# Define the simulate function\nsimulate <- function(initial_population, T, step, transaction, interaction) {\n  history <- list()  # Initialize a list to store the history of populations\n  population <- initial_population  # Start with the initial population\n  \n  # Store the initial population in the history\n  history[[1]] <- population\n  \n  for (t in 1:T) {\n    # Update population\n    population <- step(population, transaction, interaction)  \n   # Store a COPY of the updated population in the history\n    history[[t + 1]] <- population  # Not just a reference\n\n  }\n  \n  return(history)  # Return the complete history of the simulation\n}\n```\n:::\n\n\n\n\nI'm checking whether the Gini Coefficient is bigger after a different number of steps (100, 500, 1000, 5000).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (T in c(100, 500, 1000, 5000)) {\n  history <- simulate(initial_population = population_norm_nodebt, T = T, step = step, transaction = random_split, interaction = random_meeting)\n  latest_population <- history[[length(history)]]\n  gini_index_latest <- gini(latest_population)\n  cat(\"Gini index after\", T, \"iterations:\", gini_index_latest, \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGini index after 100 iterations: 0.3095326 \nGini index after 500 iterations: 0.3655959 \nGini index after 1000 iterations: 0.4197269 \nGini index after 5000 iterations: 0.4964971 \n```\n\n\n:::\n:::\n\n\n\n\nIt is. So far so good.\n\nNow onto the meat & potatoes (go, chatGPT) - trying to show the change over time in the simulation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load necessary libraries\nlibrary(ggplot2)\n\n# Define a function to calculate the percentiles\npercent <- function(pct, items) {\n  # The item that is pct percent through the sorted list of items\n  return(items[min(length(items), length(items) * pct / 100)])\n}\n\n# Function to display statistics and plots after running the simulation\nshow <- function(population, k = 40, percentiles = c(1, 10, 50, 90, 99), ...) {\n  N <- length(population)\n  start <- population\n  \n  # Store results from simulation\n  results <- lapply(seq(0, k * N, by = N / 10), function(t) {\n    pop <- sort(simulate(population, T = t, ...)[[t + 1]])  # simulate returns a list\n    return(list(t = t, pop = pop))\n  })\n  \n  # Printout:\n  cat(sprintf(\"%7s %4s %5s\", \"t\", \"Gini\", \"stdev\"), paste(sprintf(\"%3d%%\", percentiles), collapse = \" \"), \"\\n\")\n  cat(paste(rep(\"-\", 20 + 4 * length(percentiles)), collapse = \"\"), \"\\n\")\n  \n  for (res in results) {\n    pop <- res$pop\n    t <- res$t\n    data <- sapply(percentiles, function(pct) quantile(pop, pct / 100))  # Percentiles\n    cat(sprintf(\"%7d %4.2f %5.1f\", t, gini(pop), sd(pop)), paste(sprintf(\"%4.0f\", data), collapse = \" \"), \"\\n\")\n  }\n  \n  # Plotting the results\n  times <- sapply(results, `[[`, \"t\")\n  wealth_data <- sapply(results, function(x) sort(x$pop))\n  \n  # Percentile plots\n  ggplot(data.frame(wealth = unlist(wealth_data), time = rep(times, each = N))) +\n    geom_line(aes(x = wealth, y = time)) +\n    labs(title = paste(percentiles, collapse = '/'), x = \"Wealth\", y = \"Time\") +\n    theme_minimal() +\n    theme(legend.position = \"bottom\")\n  \n  # Histograms\n  par(mfrow = c(1, 2))\n  hist(start, main = \"Start Population\", xlab = \"Wealth\", col = \"blue\", breaks = 30)\n  hist(pop, main = \"End Population\", xlab = \"Wealth\", col = \"red\", breaks = 30)\n  \n  # Ordered Curves\n  order <- 1:length(pop)\n  plot(sort(start), order, type = 'l', col = \"blue\", xlab = \"Wealth\", ylab = \"Order\", main = \"Ordered Curves\")\n  lines(sort(pop), order, col = \"red\")\n  legend(\"topleft\", legend = c(\"Start\", \"End\"), col = c(\"blue\", \"red\"), lty = 1)\n}\n\nshow(population_norm_nodebt, k = 5, step = step, transaction = random_split, interaction = random_meeting)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      t Gini stdev   1%  10%  50%  90%  99% \n---------------------------------------- \n      0 0.28 4881.8    0 3251 10130 16065 21367 \n    100 0.30 5276.8    0 2956 10006 16618 24580 \n    200 0.32 5797.0    0 2585 9820 17340 24766 \n    300 0.34 6128.4  109 2264 9517 17766 27548 \n    400 0.36 6563.5    0 2223 9433 18222 29244 \n    500 0.37 6639.9   26 1931 8951 18829 29373 \n    600 0.37 6749.0   66 1936 9157 19233 29528 \n    700 0.39 7199.3   65 1766 8750 19577 31417 \n    800 0.40 7337.9  140 1743 8668 20203 32148 \n    900 0.40 7440.5   88 1526 8541 20277 32731 \n   1000 0.42 7668.4   20 1415 8521 20620 33471 \n   1100 0.43 7913.5  215 1420 8280 20549 36036 \n   1200 0.44 8216.4   93 1293 8248 21282 36309 \n   1300 0.43 8110.6  102 1491 8188 20647 36958 \n   1400 0.44 8375.1  113 1477 7862 21488 38972 \n   1500 0.44 8191.9   74 1281 8189 21057 35944 \n   1600 0.46 8689.3   79 1372 7700 21752 38092 \n   1700 0.43 8102.5  277 1510 8193 21299 36140 \n   1800 0.47 9003.0  100 1246 7494 22140 39549 \n   1900 0.46 8568.2   96 1281 7631 21778 39030 \n   2000 0.47 9150.1  106 1164 7496 21613 39846 \n   2100 0.47 9161.6  157 1129 7446 22919 39364 \n   2200 0.45 8539.1   87 1217 7895 21539 37343 \n   2300 0.48 9253.7   71  950 7378 23043 40619 \n   2400 0.47 9199.1  200 1143 7284 22851 39506 \n   2500 0.48 9191.4  124 1076 7350 21563 41253 \n   2600 0.48 9368.6   75 1128 7359 22805 41445 \n   2700 0.46 9023.0  128 1457 7489 22030 40374 \n   2800 0.49 9856.3  101 1071 7365 21840 40817 \n   2900 0.48 9515.7  161 1292 7129 21826 45216 \n   3000 0.49 9705.8  129 1138 6954 22924 43341 \n   3100 0.49 9566.3  147 1158 7320 22290 45642 \n   3200 0.50 9609.5   70  954 7332 23164 42687 \n   3300 0.50 9993.1   45 1095 6755 23163 44872 \n   3400 0.49 9448.9  107  939 7357 22523 42619 \n   3500 0.48 9410.4   45 1079 7513 21104 40755 \n   3600 0.48 9078.7  204 1158 7512 21925 39644 \n   3700 0.50 9897.0   93 1153 6957 23437 48382 \n   3800 0.50 10143.2   81 1099 7304 22576 47960 \n   3900 0.51 10540.4   99  959 6942 23048 51287 \n   4000 0.50 9837.0  105 1168 7100 23743 44723 \n   4100 0.49 9804.8  134 1138 7400 21991 47149 \n   4200 0.49 9623.8   71 1063 6985 22574 43405 \n   4300 0.49 9685.7  114 1140 7019 21972 42133 \n   4400 0.49 9755.6  100  953 6799 22820 41046 \n   4500 0.50 9610.8   86 1062 6840 23976 40296 \n   4600 0.51 10234.6  170 1075 6644 23611 42623 \n   4700 0.49 9507.5   62  934 7153 23282 40916 \n   4800 0.50 10071.4   96  988 7125 22057 46070 \n   4900 0.50 9961.7   77 1074 7023 23071 43856 \n   5000 0.51 10104.6   80  960 6663 23122 47563 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](hw2_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](hw2_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}